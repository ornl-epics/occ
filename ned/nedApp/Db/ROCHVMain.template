#
# This is for the full implementation of the embedded HV interface.  This
# includes using the hardware unit conversions and slew rate limits.  
#


#
# Summary alarm status
#
record(calc, "$(P):AlarmSum") {
   field(CALC, "1")
   field(INPA, "$(P):Volt CP MS")
   field(INPB, "$(P):Curr CP MS")
   field(INPC, "$(P):CommAlarm CP MS")
   info(archive, "Monitor, 00:00:10, VAL")
}

#
# initialization fanout.  This is because PINI doesn't work well in this
# driver.  Therefore, this fanout needs to be processed, maybe from st.cmd,
# at startup.
#
record(fanout, "$(P):InitProc") {
   field(LNK1, "$(P):RampRateSet")
   field(LNK2, "$(P):MaxVSet")
   field(LNK3, "$(P):Enable")
   field(LNK4, "$(P):VoltSet")
   field(LNK5, "$(P):VConv")
   field(LNK6, "$(P):DConv")
}

#
#  Use this one for display
#
record(ai, "$(P):RampRate") {
   field(DTYP, "stream")
   field(DESC, "Readback ramp rate")
   field(INP, "@ROCHV.proto getNum(RR) $(PORT) $(ADDR)")
   field(HOPR, "255")
   field(LOPR, "0")
   field(EGU, "ms/step")
} 

#
record(ao, "$(P):RampRateSet") {
   field(DTYP, "stream")
   field(DESC, "Set ramp rate")
   field(OUT, "@ROCHV.proto setNum(SR) $(PORT) $(ADDR)")
   field(EGU, "ms/step")
   field(HOPR, "255")
   field(DRVH, "255")
   field(LOPR, "0")
   field(DRVL, "0")
   info(autosaveFields, "VAL")
   field(FLNK, "$(P):RampRate")
}

#
# This is the raw DAC control, ie, what an ao record would usually send rval to.
# In this case it may not be used at all, or only for a crash off.  Therefore
# this ao record does not convert.
#
record(ao, "$(P):DACSet") {
   field(DTYP, "stream")
   field(DESC, "Set DAC")
   field(OUT, "@ROCHV.proto setNum(&) $(PORT) $(ADDR)")
   field(EGU, "Counts")
   field(HOPR, "4096")
   field(DRVH, "4096")
   field(LOPR, "0")
   field(DRVL, "0")
}
  
#
# This is the raw voltage ADC reading. Normally an ai record would read this
# and convert to engineering units, but in this case there is another readout
# for the converted value, so no conversion is done here. do we need to scan
# it at all?
#
record(ai, "$(P):ReadADC") {
   field(DTYP, "stream")
   field(DESC, "Read raw voltage")
   field(SCAN, "1 second")
   field(INP, "@ROCHV.proto getNum(RV) $(PORT) $(ADDR)")
   field(LOPR, 0)
   field(HOPR, 4096)
   field(EGU, "Counts")
   info(archive, "Monitor, 00:00:10, VAL")
} 

#
# Requested output in volts
#
record(ao, "$(P):VoltSet") {
   field(DTYP, "stream")
   field(DESC, "Requested voltage setpoint")
   field(OUT, "@ROCHV.proto setNum(#) $(PORT) $(ADDR)")
   field(DRVL, "0")
   field(LOPR, "0")
   field(DRVH, "2200")
   field(HOPR, "2200")
   field(EGU, "V")
   info(autosaveFields, "VAL")
}
  
#
# Voltage Readback in volts. 
#
record(ai, "$(P):Volt") {
   field(DTYP, "stream")
   field(DESC, "Readback in volts")
   field(INP, "@ROCHV.proto getNum(LV) $(PORT) $(ADDR)")
   field(LOPR, "-100")
   field(HOPR, "2300")
   field(HSV, "MAJOR")
   field(LSV, "MAJOR")
   field(EGU, "V")
   field(SCAN, "1 second")
   info(autosaveFields, "HIGH LOW")
}


#
# Converted current readback is in one document but not in legacy code.
# Also there are conversion parameters in the document, but not the code.
#
#record(ai, "$(P):Current") {
#   field(DTYP, "stream")
#   field(DESC, "converted current Readback")
#   field(INP, "@ROCHV.proto getNum(LC) $(PORT) $(ADDR))
#   field(EGU, "ma")
#   field(SCAN, "1 second")
#}

#
# Current readback.  Do it the ordinary EPICS way.  
#
# ESLO = .33 ma / 1023 bits  (for now)
#
record(ai, "$(P):Curr") {
   field(DTYP, "stream")
   field(DESC, "Current Readback")
   field(INP, "@ROCHV.proto getNum(RC) $(PORT) $(ADDR)")
   field(LINR, "SLOPE")
   field(PREC, "4")
   field(ESLO, "0.000322581")
   field(EOFF, "0")
   field(EGU, "ma")
   field(HSV, "MAJOR")
   field(LSV, "MAJOR")
   info(autosaveFields, "HIGH LOW")
   field(SCAN, "1 second")
}

#
# Max Voltage readback. Presumeably just reflects setpoint 
#
record(ai, "$(P):MaxV") {
   field(DTYP, "stream")
   field(DESC, "maximum voltage Readback")
   field(INP, "@ROCHV.proto getNum(MV) $(PORT) $(ADDR)")
   field(EGU, "V")
}

#
# set max voltage.  This is in volts, not raw DAC counts...
#
record(ao, "$(P):MaxVSet") {
   field(DTYP, "stream")
   field(DESC, "Requested voltage limit")
   field(OUT, "@ROCHV.proto setNum(M) $(PORT) $(ADDR)")
   field(DRVL, "0")
   field(LOPR, "0")
   field(DRVH, "2200")
   field(HOPR, "2200")
   field(EGU, "V")
   info(autosaveFields, "VAL")
   field(FLNK, "$(P):MaxV")
}

#
# here we have a nice switch 
#
record(bo, "$(P):Enable") {
   field(DESC, "enable/disable switch for GUI")
   field(DTYP, "Soft Channel")
   field(OUT, "$(P):EnableHW PP MS")
   field(ONAM, "ON")
   field(ZNAM, "OFF")
   info(autosaveFields, "VAL")
}

#
# ONAM and ZNAM look silly because they contain the actual commands to send
#
record(bo, "$(P):EnableHW") {
   field(DESC, "hardware enable/disable")
   field(DTYP, "stream")
   field(OUT, "@ROCHV.proto sendBoCmd() $(PORT) $(ADDR)")
   field(ONAM, "8")
   field(ZNAM, "*")
   info(autosaveFields, "VAL")
}

#
# Do the following controls by just sending "PROC"
#
record(bo, "$(P):ClearErr") {
   field(DESC, "Clear error code")
   field(DTYP, "stream")
   field(OUT, "@ROCHV.proto sendCmd(X) $(PORT) $(ADDR)")
   field(DOL, "1")
   field(ONAM, "Clear")
   field(ZNAM, "Clear")
}
record(bo, "$(P):ResetDAC") {
   field(DESC, "Yes reset the DAC")
   field(DTYP, "stream")
   field(OUT, "@ROCHV.proto sendCmd(X) $(PORT) $(ADDR)")
   field(DOL, "1")
   field(ONAM, "Reset")
   field(ZNAM, "Reset")
}

#
# Get error code. 
#
record(waveform, "$(P):ErrorInp") {
   field(DESC, "Input error byte")
   field(DTYP, "stream")
   field(INP, "@ROCHV.proto getError() $(PORT) $(ADDR)")
   field(FTVL, "UCHAR")
   field(NELM, "2")
   field(SCAN, "1 second")
   field(FLNK, "$(P):ErrorBits")
}

#
# convert to bits. Point byte widget to VAL or RVAL
#
record(mbbiDirect, "$(P):ErrorBits") {
   field(DESC, "Provide Error Bits")
   field(DTYP, "Raw Soft Channel")
   field(INP, "$(P):ErrorInp NPP MS")
}

record(bi, "$(P):CommAlarm") {
   field(DTYP, "Raw Soft Channel")
   field(INP, "$(P):ErrorBits.RVAL CPP NMS")
   field(OSV, "MAJOR")
   field(ZSV, "NO_ALARM")
}

#
# This is for debugging
#
record(asyn,"$(P):AsynRec")
{
    field(DTYP,"asynRecordDevice")
    field(PORT,"$(PORT)")
    field(ADDR,"$(ADDR)")
    field(OMAX,"30")
    field(IMAX,"30")
}

#
# Conversion (Calibration) parameters set.  the idea here is that you
# set the 3 individual records, then PROC the top one to drive them...
#
# Set for the DAC
#
record(ao, "$(P):DConvSet") {
   field(DTYP, "stream")
   field(OUT, "@ROCHV.proto setCalA(SD,$(P):DConvSet) $(PORT) $(ADDR)")
   field(FLNK, "$(P):DConvX")
}
record(ao, "$(P):DConvSetX") {
   field(DRVH, "65535")
   field(HOPR, "65535")
   field(LOPR, "0")
   field(DRVL, "0")
   info(autosaveFields, "VAL")
}
record(ao, "$(P):DConvSetY") {
   field(DRVH, "65535")
   field(HOPR, "65535")
   field(LOPR, "0")
   field(DRVL, "0")
   info(autosaveFields, "VAL")
}
record(ao, "$(P):DConvSetZ") {
   field(HOPR, "65535")
   field(LOPR, "0")
   info(autosaveFields, "VAL")
}

#
# Check out what it does.  note this works before writing. Produces DAC setting
#
record(calc, "$(P):DSim") {
   field(INPA, "$(P):DConvSetX CPP")
   field(INPB, "$(P):DConvSetY CPP")
   field(INPC, "$(P):DConvSetZ CPP")
   field(INPD, "$(P):VoltSet CPP MS")
   field(CALC, "D*(A/B)+C")
}

#
# get records 
#
record(ai, "$(P):DConvX") {
   field(DTYP, "stream")
   field(INP, "@ROCHV.proto getCalXYZ(CD,$(P):DConv) $(PORT) $(ADDR)")
   field(HOPR, "65535")
   field(LOPR, "0")
}
record(ai, "$(P):DConvY") {
   field(HOPR, "65535")
   field(LOPR, "0")
}
record(ai, "$(P):DConvZ") {
   field(HOPR, "65535")
   field(LOPR, "0")
}

#
# Conversion (Calibration) parameters set.  the idea here is that you
# set the 3 individual records, then PROC the top one to drive them...
#
# Set for the ADC
#
record(ao, "$(P):VConvSet") {
   field(DTYP, "stream")
   field(OUT, "@ROCHV.proto setCalA(SV,$(P):VConvSet) $(PORT) $(ADDR)")
   field(FLNK, "$(P):VConvX")
}
record(ao, "$(P):VConvSetX") {
   field(DRVH, "65535")
   field(HOPR, "65535")
   field(LOPR, "0")
   field(DRVL, "0")
   info(autosaveFields, "VAL")
}
record(ao, "$(P):VConvSetY") {
   field(DRVH, "65535")
   field(HOPR, "65535")
   field(LOPR, "0")
   field(DRVL, "0")
   info(autosaveFields, "VAL")
}
record(ao, "$(P):VConvSetZ") {
   field(HOPR, "65535")
   field(LOPR, "0")
   info(autosaveFields, "VAL")
}

#
# Check out what it does.  note this works before writing. 
#
record(calc, "$(P):VSim") {
   field(INPA, "$(P):VConvSetX CPP")
   field(INPB, "$(P):VConvSetY CPP")
   field(INPC, "$(P):VConvSetZ CPP")
   field(INPD, "$(P):ReadADC PP MS")
   field(CALC, "D*(A/B)+C")
}

#
# get records 
#
record(ai, "$(P):VConvX") {
   field(DTYP, "stream")
   field(INP, "@ROCHV.proto getCalXYZ(CV,$(P):VConv) $(PORT) $(ADDR)")
   field(HOPR, "65535")
   field(LOPR, "0")
}
record(ai, "$(P):VConvY") {
   field(HOPR, "65535")
   field(LOPR, "0")
}
record(ai, "$(P):VConvZ") {
   field(HOPR, "65535")
   field(LOPR, "0")
}

