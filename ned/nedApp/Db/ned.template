record(mbbi, "$(P)$(R)Status")
{
    field(DESC, "Status of OccPortDriver")
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))Status")
    field(ZRVL, "0")
    field(ONVL, "1")
    field(TWVL, "2")
    field(ZRST, "OK")
    field(ONST, "RX buffer full")
    field(TWST, "OCC error")
    field(SCAN, "I/O Intr")
}
record(mbbo, "$(P)$(R)Command")
{
    field(DESC, "Issue OccPortDriver command")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))Command")
    field(ZRVL, "0")
    field(ONVL, "1")
    field(TWVL, "2")
    field(THVL, "3")
    field(FRVL, "4")
    field(ZRST, "None")
    field(ONST, "Optics enable")
    field(TWST, "Optics disable")
    field(THST, "Error packets enable")
    field(FRST, "Error packets disable")
    field(PINI, "YES")
    field(VAL,  "1")
}

record(mbbi, "$(P)$(R)BoardStatus")
{
    field(DESC, "OCC board status")
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))BoardStatus")
    # Those match to return code of occ_open()
    field(ZRVL, "0")
    field(ONVL, "1")  # EPERM
    field(TWVL, "2")  # ENOENT
    field(THVL, "42") # ENOMSG
    field(FRVL, "61") # ENODATA
    field(ZRST, "Ready")
    field(ONST, "Permission denied")
    field(TWST, "No device")
    field(THST, "Version mismatch")
    field(FRST, "Interface error")
    field(SCAN, "I/O Intr")
}
record(mbbi, "$(P)$(R)BoardType")
{
    field(DESC, "OCC board type")
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))BoardType")
    field(ONVL, "1")
    field(TWVL, "2")
    field(FFVL, "15")
    field(ONST, "SNS PCI-X")
    field(TWST, "SNS PCI Express")
    field(FFST, "Simulator")
}
record(bi, "$(P)$(R)BoardFwVer")
{
    field(DESC, "OCC board firmware version")
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))BoardFwVer")
}
record(bi, "$(P)$(R)OpticsPresent")
{
    field(DESC, "Is optical cable present")
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))OpticsPresent")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "1 second")
}
record(bi, "$(P)$(R)OpticsEnabled")
{
    field(DESC, "Is optical link enabled")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))OpticsEnabled")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "1 second")
}
record(bi, "$(P)$(R)ErrPktsEnabled")
{
    field(DESC, "Turn link errors into error packets")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))ErrPktsEnabled")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(PINI, "YES")
    field(VAL,  "0")
}
record(ai, "$(P)$(R)FpgaTemp")
{
    field(DESC, "FPGA temperature")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))FpgaTemp")
    field(EGU,  "Celsius")
    field(SCAN, "1 second")
}
record(ai, "$(P)$(R)FpgaCoreVolt")
{
    field(DESC, "FPGA core voltage")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))FpgaCoreVolt")
    field(EGU,  "Volt")
    field(SCAN, "1 second")
}
record(ai, "$(P)$(R)FpgaAuxVolt")
{
    field(DESC, "FPGA AUX voltage")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))FpgaAuxVolt")
    field(EGU,  "Volt")
    field(SCAN, "1 second")
}
record(ai, "$(P)$(R)SfpTemp")
{
    field(DESC, "SFP temperature")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))SfpTemp")
    field(EGU,  "Celsius")
    field(SCAN, "1 second")
}
record(ai, "$(P)$(R)SfpRxPower")
{
    field(DESC, "SFP RX power")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))SfpRxPower")
    field(EGU,  "uW")
    field(SCAN, "1 second")
}
record(ai, "$(P)$(R)SfpTxPower")
{
    field(DESC, "SFP TX power")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))SfpTxPower")
    field(EGU,  "uW")
    field(SCAN, "1 second")
}
record(ai, "$(P)$(R)SfpVccPower")
{
    field(DESC, "SFP VCC power")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))SfpVccPower")
    field(EGU,  "Volt")
    field(SCAN, "1 second")
}
record(ai, "$(P)$(R)SfpTxBiasCur")
{
    field(DESC, "SFP TX bias current")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))SfpTxBiasCur")
    field(EGU,  "uA")
    field(SCAN, "1 second")
}
record(longin, "$(P)$(R)ErrCrc")
{
    field(DESC, "FPGA detected CRC errors counter")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))ErrCrc")
    field(SCAN, "1 second")
}
record(longin, "$(P)$(R)ErrLength")
{
    field(DESC, "FPGA detected length errors counter")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))ErrLength")
    field(SCAN, "1 second")
}
record(longin, "$(P)$(R)ErrFrame")
{
    field(DESC, "FPGA detected frame errors counter")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))ErrFrame")
    field(SCAN, "1 second")
}
record(longin, "$(P)$(R)DmaBufUtil")
{
    field(DESC, "DMA buffer utilization")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))DmaBufUtil")
    field(SCAN, "1 second")
    field(EGU,  "%")
}
record(longin, "$(P)$(R)CopyBufUtil")
{
    field(DESC, "Local buffer utilization")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))CopyBufUtil")
    field(SCAN, "1 second")
    field(EGU,  "%")
}
