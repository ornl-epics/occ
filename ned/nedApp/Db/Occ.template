record(mbbi, "$(P)Status")
{
    field(DESC, "Status of OccPortDriver")
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))Status")
    field(ZRVL, "0")
    field(ONVL, "1")
    field(TWVL, "2")
    field(ZRST, "OK")
    field(ONST, "RX buffer full")
    field(TWST, "OCC error")
    field(SCAN, "I/O Intr")
}
record(mbbo, "$(P)Command")
{
    field(DESC, "Issue OccPortDriver command")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT))Command")
    field(ZRVL, "0")
    field(ONVL, "1")
    field(TWVL, "2")
    field(THVL, "3")
    field(FRVL, "4")
    field(ZRST, "None")
    field(ONST, "Optics enable")
    field(TWST, "Optics disable")
    field(THST, "Error packets enable")
    field(FRST, "Error packets disable")
    field(PINI, "YES")
    field(VAL,  "1")
}

record(mbbi, "$(P)LastErr")
{
    field(DESC, "Last error returned from OCC library")
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))LastErr")
    # Those match to return code of occ_*() functions
    field(ZRVL, "0")
    field(ONVL, "1")  # EPERM
    field(TWVL, "2")  # ENOENT
    field(THVL, "42") # ENOMSG
    field(FRVL, "61") # ENODATA
    field(FVVL, "75") # EOVERFLOW
    field(SXVL, "104") # ECONNRESET
    field(ZRST, "No error")
    field(ONST, "Permission denied")
    field(TWST, "No device")
    field(THST, "Version mismatch")
    field(FRST, "Interface error")
    field(FVST, "Buffer full")
    field(SXST, "Device reset")
    field(SCAN, "I/O Intr")
}
record(mbbi, "$(P)BoardType")
{
    field(DESC, "OCC board type")
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))BoardType")
    field(ONVL, "1")
    field(TWVL, "2")
    field(FFVL, "15")
    field(ONST, "SNS PCI-X")
    field(TWST, "SNS PCI Express")
    field(FFST, "Simulator")
}
record(longin, "$(P)BoardFwVer")
{
    field(DESC, "OCC board firmware version")
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))BoardFwVer")
}
record(bi, "$(P)OpticsPresent")
{
    field(DESC, "Is optical cable present")
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))OpticsPresent")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "1 second")
}
record(bi, "$(P)OpticsEnabled")
{
    field(DESC, "Is optical link enabled")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))OpticsEnabled")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "1 second")
}
record(mbbi, "$(P)RxStalled")
{
    field(DESC, "Incoming data stalled")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))RxStalled")
    field(ZRVL, "0")
    field(ONVL, "1")
    field(TWVL, "2")
    field(THVL, "3")
    field(ZRST, "Not stalled")
    field(ONST, "OCC stalled")
    field(TWST, "Copy thread stalled")
    field(THST, "OCC and copy stalled")
    field(SCAN, "1 second")
    field(VAL,  "0")
}
record(bi, "$(P)ErrPktsEnabled")
{
    field(DESC, "Turn link errors into error packets")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))ErrPktsEnabled")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(PINI, "YES")
    field(VAL,  "0")
}
record(ai, "$(P)FpgaTemp")
{
    field(DESC, "FPGA temperature")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT))FpgaTemp")
    field(EGU,  "Celsius")
    field(SCAN, "1 second")
}
record(ai, "$(P)FpgaCoreVolt")
{
    field(DESC, "FPGA core voltage")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT))FpgaCoreVolt")
    field(EGU,  "Volt")
    field(SCAN, "1 second")
}
record(ai, "$(P)FpgaAuxVolt")
{
    field(DESC, "FPGA AUX voltage")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT))FpgaAuxVolt")
    field(EGU,  "Volt")
    field(SCAN, "1 second")
}
record(ai, "$(P)SfpTemp")
{
    field(DESC, "SFP temperature")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT))SfpTemp")
    field(EGU,  "Celsius")
    field(SCAN, "1 second")
}
record(ai, "$(P)SfpRxPower")
{
    field(DESC, "SFP RX power")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT))SfpRxPower")
    field(EGU,  "uW")
    field(SCAN, "1 second")
}
record(ai, "$(P)SfpTxPower")
{
    field(DESC, "SFP TX power")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT))SfpTxPower")
    field(EGU,  "uW")
    field(SCAN, "1 second")
}
record(ai, "$(P)SfpVccPower")
{
    field(DESC, "SFP VCC power")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT))SfpVccPower")
    field(EGU,  "Volt")
    field(SCAN, "1 second")
}
record(ai, "$(P)SfpTxBiasCur")
{
    field(DESC, "SFP TX bias current")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT))SfpTxBiasCur")
    field(EGU,  "uA")
    field(SCAN, "1 second")
}
record(longin, "$(P)ErrCrc")
{
    field(DESC, "FPGA detected CRC errors counter")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))ErrCrc")
    field(SCAN, "1 second")
}
record(longin, "$(P)ErrLength")
{
    field(DESC, "FPGA detected length errors counter")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))ErrLength")
    field(SCAN, "1 second")
}
record(longin, "$(P)ErrFrame")
{
    field(DESC, "FPGA detected frame errors counter")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))ErrFrame")
    field(SCAN, "1 second")
}
record(longin, "$(P)DmaBufUtil")
{
    field(DESC, "DMA buffer utilization")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))DmaBufUtil")
    field(SCAN, "1 second")
    field(EGU,  "%")
}
record(longin, "$(P)CopyBufUtil")
{
    field(DESC, "Local buffer utilization")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))CopyBufUtil")
    field(SCAN, "1 second")
    field(EGU,  "%")
}
record(ao, "$(P)StatusInt")
{
    field(DESC, "Basic status update interval")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT))StatusInt")
    field(EGU,  "seconds")
}
record(ao, "$(P)ExtStatusInt")
{
    field(DESC, "Extended status update interval")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT))ExtStatusInt")
    field(EGU,  "seconds")
}
